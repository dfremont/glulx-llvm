# Generator for clangglk.h
# (Glk wrappers for use with the LLVM backend for Glulx)
# by Daniel Fremont
# 
# This file is in the public domain.
#
# Usage: run in the same directory as the 'glk.h' header file you want to
# create wrappers for, as well as the 'dispatch_dump.xml' file created by
# the 'dispatch_dump' tool (see https://github.com/erkyrath/glk-dev/). The
# new file will be printed to standard out, so you may want to redirect it,
# i.e. run "python parseglk.py > clangglk.h".

import re
import warnings
import xml.etree.ElementTree as ET

prolog = r"""
#ifndef CLANGGLK_H
#define CLANGGLK_H

#ifndef size_t
typedef unsigned long size_t;
#endif

// Library function which the backend will turn into @mcopy.
void* memcpy(void *restrict dest, const void *restrict src, size_t count);

// Various utilities used in the Glk function wrappers

#ifdef GLK_ALLOW_CSTRINGS

static char *_prepare_raw_cstring(char *string) {
    char *p = string;
    size_t i;
    for (i = 1; *p++; ++i) ;
    p = __malloc(i+1);
    p[0] = 0xE0;
    memcpy(p+1, string, i);
    return p;
}

#define PREPARE_CSTRING(s) \
    int _is_cstring = (unsigned char) *s < 0xE0 || (unsigned char) *s > 0xE2; \
    if (_is_cstring) \
        s = _prepare_raw_cstring(s);
#define FINISH_CSTRING(s) \
    if (_is_cstring) \
        __mfree(s);

#else   // GLK_ALLOW_CSTRINGS

#define PREPARE_CSTRING(s)
#define FINISH_CSTRING(s)

#endif  // GLK_ALLOW_CSTRINGS

// Modified glk.h with implementations of Glk functions
"""

epilog = """
#endif  // CLANGGLK_H
"""

cstringFuncs = (
    'glk_put_string', 'glk_put_string_stream', 'glk_fileref_create_by_name',
)
cstringArgTy = 'char *'
cstringHandlerProlog = """
    PREPARE_CSTRING({arg})
"""
cstringHandlerEpilog = """
    FINISH_CSTRING({arg})
"""

# Parse dispatch XML file to get function IDs

tree = ET.parse('dispatch_dump.xml')
root = tree.getroot()
glkVersion = root.get('version')
funcIDs = {}
for func in root.iter('function'):
    name, ID = func.get('name'), func.get('id')
    funcIDs[name] = int(ID)

# Emit prolog

print('// clangglk.h -- auto-generated by parseglk.py')
print(f'// generated for Glk API version {glkVersion}')
print(prolog)

# Parse glk.h to get function prototypes; emit their implementations

with open('glk.h', 'r') as f:
    data = f.read()

protoPat = r'^extern\s*((?:\w|\ )*?)\s*(\w*)\(([\w\s,\*]*)\)\s*(\w*);'
numGroups = 4
uncastTypes = ('glui32', 'glsi32', 'char', 'unsigned char')

#for match in re.findall(protoPat, data, flags=re.MULTILINE):

parts = re.split(protoPat, data, flags=re.MULTILINE)
i = 0
while True:
    print(parts[i], end='')
    i = i + 1
    if i >= len(parts):
        break
    match = parts[i:i+numGroups]
    i = i + numGroups
    retTy, name, allArgs, attributes = match
    unprefixedName = name[4:]
    ID = funcIDs.get(unprefixedName)
    if not ID:
        warnings.warn(f'skipping function {name} not listed in XML file')
        continue
    args = []
    for arg in allArgs.split(','):
        argData = arg.strip().rsplit(maxsplit=1)
        if len(argData) != 2:
            if len(argData) == 1 and argData[0] == 'void':
                break
            else:
                raise RuntimeError(f'unable to parse argument {arg}')
        if argData[1][0] == '*':    # pointer argument
            argData = [argData[0]+' *', argData[1][1:]]
        args.append(argData)
    retStatement = 'return ' if retTy != 'void' else ''
    attributes = attributes.strip()
    noReturn = False
    if attributes:
        if attributes == 'GLK_ATTRIBUTE_NORETURN':
            noReturn = True
            if retStatement:
                raise RuntimeError(f'noreturn function {name} has non-void return type')
        else:
            warnings.warn(f'ignoring unknown function attributes {attributes}')

    print('__attribute__((always_inline))')
    print(f'static {retTy} {name}({allArgs}) {{')
    cstringArg = None
    if name in cstringFuncs:
        for ty, argName in args:
            if ty == cstringArgTy:
                if cstringArg:
                    raise RuntimeError(f'cstring argument for {name} is ambiguous')
                cstringArg = argName
        if not cstringArg:
            raise RuntimeError(f'could not find cstring argument for {name}')
        print(cstringHandlerProlog.format(arg=cstringArg))
    for argTy, argName in reversed(args):
        if argTy not in uncastTypes:
            cast = '(int) '
        else:
            cast = ''
        print(f'    __push({cast}{argName});')
    cast = '' if not retStatement or retTy in uncastTypes else f'({retTy}) '
    if cstringArg and retStatement:
        retStatement = f'{retTy} _ret = '
    print(f'    {retStatement}{cast}__glk({ID}, {len(args)});')
    if cstringArg:
        print(cstringHandlerEpilog.format(arg=cstringArg))
        if retStatement:
            print('    return _ret;')
    if noReturn:
        print(f'    __builtin_unreachable();')
    print('}', end='')

# Emit epilog

print(epilog)
